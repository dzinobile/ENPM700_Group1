# -*- coding: utf-8 -*-
"""camera_calibration.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1T7tuPrzAhE5_oMAl_aLpD7JKhdDTk2DW
"""

# Commented out IPython magic to ensure Python compatibility.
# mount drive


import cv2
import numpy as np
from matplotlib import pyplot as plt



#THIS CODE JUST CLIPS THE VIDEO SO IT DOESNT NEED TO RUN SO MANY FRAMES


# i = 0
# fourcc = cv2.VideoWriter_fourcc(*'mp4v')
# checkerboard_clipped = cv2.VideoWriter('checkerboard_clipped.mp4', fourcc, 25.0,(image_w, image_h))
# while True:
#   ret, frame = capture.read()
#   if not ret:
#     break
#   i+=1
#   if i%10==0:
#     checkerboard_clipped.write(frame)


# capture.release()
# checkerboard_clipped.release()

# Find chessboard points in each image

# Termination criteria: maximum 30 iterations, error threshold 0.001
criteria = (cv2.TERM_CRITERIA_EPS + cv2.TERM_CRITERIA_MAX_ITER, 30, 0.001)

# Initialize object points to be added to list
objp = np.zeros((8*6,3), np.float32)
objp[:,:2] = np.mgrid[0:8,0:6].T.reshape(-1,2)

# Initialize object points and image points list
objpoints = [] # 3D coordinates of point on checkerboard
imgpoints = [] # 2D coordinates of points on image

# # Find chessboard corners for each image
# for i in range(0,50):
#   image = images[i].copy()
#   gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)

#   # Find chessboard corners, additional flags for adaptive thresholding and normalizing image brightness and contrast
#   ret, corners = cv2.findChessboardCorners(gray, (10,7), cv2.CALIB_CB_ADAPTIVE_THRESH + cv2.CALIB_CB_NORMALIZE_IMAGE)


#   if ret == True: # If all corners found:
#     objpoints.append(objp) # Add corner 3D coordinates to object points list
#     corners2 = cv2.cornerSubPix(gray, corners, (5,5), (-1,-1), criteria) # Refine 2D corner locations
#     imgpoints.append(corners2) # Add 2D corner locations to list

capture = cv2.VideoCapture('media/checkerboard_clipped.mp4')
ret, frame = capture.read()
image_h, image_w, _ = frame.shape


while True:
  ret, frame = capture.read()
  if not ret:
    break
  image = frame.copy()
  gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
  ret2, corners = cv2.findChessboardCorners(gray, (8,6), cv2.CALIB_CB_ADAPTIVE_THRESH + cv2.CALIB_CB_NORMALIZE_IMAGE)
  if ret2 == True:
    objpoints.append(objp)  # Add corner 3D coordinates to object points list
    corners2 = cv2.cornerSubPix(gray, corners, (5,5), (-1,-1), criteria) # Refine 2D corner locations
    imgpoints.append(corners2) # Add 2D corner locations to list


# Camera calibration
# Return camera matrix, distortion coefficients, rotation vectors, and translation vectors
# Matrix is of intrinsic parameters and does not depend on the scene being viewed
ret, mtx, dist, rvecs, tvecs = cv2.calibrateCamera(objpoints, imgpoints, gray.shape[::-1], None, None)
print(mtx)
print(dist)
print(rvecs)
print(tvecs)

